// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

@experimental
library build_runner.src.generate.performance_tracker;

import 'dart:async';

import 'package:build/build.dart';
import 'package:logging/logging.dart';
import 'package:meta/meta.dart';

import 'package:build_runner/src/util/clock.dart';
import 'phase.dart';

class TimeInterval {
  Duration get duration => stopTime.difference(startTime);

  /// When this operation started, call [start] to set this.
  DateTime get startTime => _startTime;
  DateTime _startTime;

  /// When this operation stopped, call [stop] to set this.
  DateTime get stopTime => _stopTime;
  DateTime _stopTime;

  /// Start tracking this operation, must only be called once, before [stop].
  void start() {
    assert(_startTime == null && _stopTime == null);
    _startTime = now();
  }

  /// Stop tracking this operation, must only be called once, after [start].
  void stop() {
    assert(_startTime != null && _stopTime == null);
    _stopTime = now();
  }
}

/// The timings of an operation, including its [timeIntervals] and [duration].
abstract class Timings {
  Duration get duration => timeIntervals.fold(
      new Duration(), (Duration combined, next) => combined + next.duration);
  Iterable<TimeInterval> get timeIntervals;
}

/// The [Timings] of an entire build, including all its [actions].
abstract class BuildPerformance implements Timings {
  /// The [Timings] of each phase ran in this build.
  Iterable<BuildPhasePerformance> get phases;

  /// The [Timings] of running an individual [Builder] on an individual input.
  Iterable<BuilderActionPerformance> get actions;
}

/// The [Timings] of a full [BuildPhase] within a larger build.
abstract class BuildPhasePerformance implements Timings {
  BuildPhase get action;
}

/// The [Timings] of a [builder] running on [primaryInput] within a build.
abstract class BuilderActionPerformance implements Timings {
  Builder get builder;
  AssetId get primaryInput;
  Iterable<BuilderActionPhasePerformance> get phases;
}

/// The [Timings] of a particular task within a builder action.
///
/// This is some slice of overall [BuilderActionPerformance].
abstract class BuilderActionPhasePerformance implements Timings {
  String get label;
}

/// Interface for tracking the overall performance of a build.
abstract class BuildPerformanceTracker
    implements TimeTracker, BuildPerformance {
  /// Tracks [runPhase] which performs [action] on all inputs in a phase, and
  /// return the outputs generated.
  Future<Iterable<AssetId>> trackBuildPhase(
      BuildPhase action, Future<Iterable<AssetId>> runPhase());

  /// Returns a [BuilderActionTracker] for tracking [builder] on [primaryInput]
  /// and adds it to [actions].
  BuilderActionTracker createBuilderAction(
      AssetId primaryInput, Builder builder);

  factory BuildPerformanceTracker() => new _BuildPerformanceTrackerImpl();

  /// A [BuildPerformanceTracker] with as little overhead as possible. Does no
  /// actual tracking and does not implement many fields/methods.
  factory BuildPerformanceTracker.noOp() =>
      _NoOpBuildPerformanceTracker.sharedInstance;
}

/// Real implementation of [BuildPerformanceTracker].
///
/// Use [BuildPerformanceTracker] factory to get an instance.
class _BuildPerformanceTrackerImpl extends _TimeTrackerImpl
    implements BuildPerformanceTracker {
  @override
  Iterable<BuildPhaseTracker> get phases => _phases;
  final _phases = <BuildPhaseTracker>[];

  @override
  Iterable<BuilderActionTracker> get actions => _actions;
  final _actions = <BuilderActionTracker>[];

  /// Tracks [action] which is ran with [runPhase].
  ///
  /// This represents running a [Builder] on a group of sources.
  ///
  /// Returns all the outputs generated by the phase.
  @override
  Future<Iterable<AssetId>> trackBuildPhase(
      BuildPhase action, Future<Iterable<AssetId>> runPhase()) {
    assert(isRunning);
    var tracker = new BuildPhaseTracker(action);
    _phases.add(tracker);
    var zone = performanceTrackingZone(tracker);
    return zone.run(runPhase);
  }

  /// Returns a new [BuilderActionTracker] and adds it to [actions].
  ///
  /// The [BuilderActionTracker] will already be started, but you must stop it.
  @override
  BuilderActionTracker createBuilderAction(
      AssetId primaryInput, Builder builder) {
    assert(isRunning);
    var tracker = new BuilderActionTracker(primaryInput, builder);
    _actions.add(tracker);
    return tracker;
  }
}

/// No-op implementation of [BuildPerformanceTracker].
///
/// Read-only fields will throw, and tracking methods just directly invoke their
/// closures without tracking anything.
///
/// Use [BuildPerformanceTracker.noOp] to get an instance.
class _NoOpBuildPerformanceTracker extends Object
    with _NoOpTimeTracker
    implements BuildPerformanceTracker {
  static final _NoOpBuildPerformanceTracker sharedInstance =
      new _NoOpBuildPerformanceTracker();

  @override
  Iterable<BuilderActionTracker> get actions => throw new UnimplementedError();

  @override
  Iterable<BuildPhaseTracker> get phases => throw new UnimplementedError();

  @override
  BuilderActionTracker createBuilderAction(
          AssetId primaryInput, Builder builder) =>
      new BuilderActionTracker.noOp();

  @override
  Future<Iterable<AssetId>> trackBuildPhase(
          BuildPhase action, Future<Iterable<AssetId>> runPhase()) =>
      runPhase();
}

/// Internal class that tracks the [Timings] of an entire [BuildPhase].
///
/// Tracks total time it took to run on all inputs available to that action.
///
/// This is only meaningful for non-lazy phases.
class BuildPhaseTracker extends _TimeTrackerImpl
    implements BuildPhasePerformance {
  @override
  final BuildPhase action;

  BuildPhaseTracker(this.action);
}

/// Interface for tracking the [Timings] of an indiviual [Builder] on a given
/// primary input.
abstract class BuilderActionTracker
    implements TimeTracker, BuilderActionPerformance {
  /// Tracks the time of [runPhase] and associates it with [label].
  FutureOr<T> track<T>(FutureOr<T> runPhase(), String label);

  factory BuilderActionTracker(AssetId primaryInput, Builder builder) =>
      new _BuilderActionTrackerImpl(primaryInput, builder);

  /// A [BuilderActionTracker] with as little overhead as possible. Does no
  /// actual tracking and does not implement many fields/methods.
  factory BuilderActionTracker.noOp() =>
      _NoOpBuilderActionTracker._sharedInstance;
}

/// Real implementation of [BuilderActionTracker] which records timings.
///
/// Use the [BuilderActionTracker] factory to get an instance.
class _BuilderActionTrackerImpl extends _TimeTrackerImpl
    implements BuilderActionTracker {
  @override
  final Builder builder;
  @override
  final AssetId primaryInput;

  @override
  final List<BuilderActionPhaseTracker> phases = [];

  _BuilderActionTrackerImpl(this.primaryInput, this.builder);

  @override
  FutureOr<T> track<T>(FutureOr<T> action(), String label) {
    var tracker = new BuilderActionPhaseTracker(label);
    phases.add(tracker);
    var zone = performanceTrackingZone(tracker);
    return zone.run(action);
  }
}

/// No-op instance of [BuilderActionTracker] which does nothing and throws an
/// unimplemented error for everything but [track], which delegates directly to
/// the wrapped function.
///
/// Use the [BuilderActionTracker.noOp] factory to get an instance.
class _NoOpBuilderActionTracker extends Object
    with _NoOpTimeTracker
    implements BuilderActionTracker {
  static final _NoOpBuilderActionTracker _sharedInstance =
      new _NoOpBuilderActionTracker();

  @override
  Builder get builder => throw new UnimplementedError();

  @override
  Duration get duration => throw new UnimplementedError();

  @override
  Iterable<BuilderActionPhasePerformance> get phases =>
      throw new UnimplementedError();

  @override
  AssetId get primaryInput => throw new UnimplementedError();

  @override
  FutureOr<T> track<T>(FutureOr<T> runPhase(), String label) => runPhase();
}

/// Tracks the [Timings] of an indivual task.
///
/// These represent a slice of the [BuilderActionPerformance].
class BuilderActionPhaseTracker extends _TimeTrackerImpl
    implements BuilderActionPhasePerformance {
  @override
  final String label;

  BuilderActionPhaseTracker(this.label);
}

/// Interface for tracking the [Timings] of an operation using the [start] and
/// [stop] methods.
abstract class TimeTracker implements Timings {
  static const zoneKey = #TimeTracker;

  factory TimeTracker() => new _TimeTrackerImpl();
  factory TimeTracker.noOp() => _NoOpTimeTracker.sharedInstance;

  bool get isRunning;
  void start();
  void stop();
}

/// Implementation of a real [TimeTracker].
///
/// Use [TimeTracker] factory to get an instance.
class _TimeTrackerImpl extends Timings implements TimeTracker {
  final _timeIntervals = <TimeInterval>[];

  TimeInterval _nextInterval;

  @override
  bool get isRunning => _nextInterval != null;

  @override
  Iterable<TimeInterval> get timeIntervals => _timeIntervals;

  /// Start tracking this operation, may only be called if currently stopped.
  @override
  void start() {
    assert(_nextInterval == null);
    _nextInterval = new TimeInterval()..start();
  }

  /// Stop tracking this operation, may only be called if currently started.
  @override
  void stop() {
    assert(_nextInterval != null);
    if (_nextInterval == null) {
      // new Logger('PerformanceTracker')
      //     .warning('Getting stop for some reason $this');
      return;
    }
    _nextInterval.stop();
    _timeIntervals.add(_nextInterval);
    _nextInterval = null;
  }
}

/// No-op implementation of [TimeTracker] that does nothing.
///
/// Use [TimeTracker.noOp] factory to get an instance.
class _NoOpTimeTracker implements TimeTracker {
  static final sharedInstance = new _NoOpTimeTracker();

  @override
  Duration get duration => throw new UnimplementedError();

  @override
  bool get isRunning => throw new UnimplementedError();

  @override
  Iterable<TimeInterval> get timeIntervals => throw new UnimplementedError();

  @override
  void start() {}

  @override
  void stop() {}
}

Zone performanceTrackingZone(TimeTracker timeTracker) {
  TimeTracker actualTracker(Zone self, Zone original) {
    if (self == original) return original[TimeTracker.zoneKey] as TimeTracker;
    return null;
  }

  TimeTracker runningParentTracker(Zone self, Zone original) {
    if (self == original) return null;
    var selfTracker = self[TimeTracker.zoneKey] as TimeTracker;
    if (selfTracker == null) return null;
    if (selfTracker.isRunning) return selfTracker;
    return null;
  }

  var specification = new ZoneSpecification(
    scheduleMicrotask: (self, parent, zone, callback) {
      var wrapped = () {
        var tracker = actualTracker(self, zone);
        var parentTracker = runningParentTracker(self, zone);
        parentTracker?.stop();
        tracker?.start();
        try {
          callback();
        } finally {
          tracker?.stop();
          parentTracker?.start();
        }
      };
      parent.scheduleMicrotask(zone, wrapped);
    },
    run: <R>(Zone self, ZoneDelegate parent, Zone zone, R callback()) {
      var tracker = actualTracker(self, zone);
      var parentTracker = runningParentTracker(self, zone);
      parentTracker?.stop();
      tracker?.start();
      try {
        return parent.run(zone, callback);
      } finally {
        tracker?.stop();
        parentTracker?.start();
      }
    },
    runUnary: <R, T>(Zone self, ZoneDelegate parent, Zone zone, R callback(T _),
        T arg) {
      var tracker = actualTracker(self, zone);
      var parentTracker = runningParentTracker(self, zone);
      parentTracker?.stop();
      tracker?.start();
      try {
        return parent.runUnary(zone, callback, arg);
      } finally {
        tracker?.stop();
        parentTracker?.start();
      }
    },
    runBinary: <R, T1, T2>(Zone self, ZoneDelegate parent, Zone zone,
        R callback(T1 _, T2 __), T1 arg1, T2 arg2) {
      var tracker = actualTracker(self, zone);
      var parentTracker = runningParentTracker(self, zone);
      parentTracker?.stop();
      tracker?.start();
      try {
        return parent.runBinary(zone, callback, arg1, arg2);
      } finally {
        tracker?.stop();
        parentTracker?.start();
      }
    },
  );
  var zone = Zone.current.fork(
      specification: specification,
      zoneValues: {TimeTracker.zoneKey: timeTracker});
  return zone;
}
